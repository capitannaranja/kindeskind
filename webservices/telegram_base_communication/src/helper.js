var stripAnsi = require('strip-ansi');
var config = require('./config.js');
const fs = require('fs');
var https = require('https');

var helper = {};

/**
 * Generate a telegram-cli conform cli command
 */
helper.buildTelegramCommand = function (pathToTelegramCLI, command, param1, param2) {
    if (param1 != null && param1 != undefined) {
        param1 = param1.split(' ').join('_');
    }
    return pathToTelegramCLI + " --json -CWe \"" + command + " " + param1 + " " + param2 + "\"";
};

/**
 * Format telegram-cli output data to more readable format
 */
helper.formatTelegramOutput = function (rawOutput) {
    rawOutput = stripAnsi(rawOutput);
    return rawOutput.substring(rawOutput.indexOf('> ') + 7, rawOutput.length);
};

/**
 * Get filename of jsonl backup files generated by telegram-history-dump lua script
 */
helper.getAllJSONLFilenames = () => {
    return new Promise(
        (resolve, reject) => {
            const pathToJSONLFiles = config.pathToJSONLFiles;
            var result = [];
            fs.readdir(pathToJSONLFiles, (err, files) => {
                if (files != null) {
                    files.forEach(file => {
                        result.push(file);
                    });
                    resolve(result);
                } else {
                    reject(err);
                }
            });
        }
    );
};

/**
 * Get all unread messages of a specific sender extracted from the corresponding jsonl file
 */
helper.getUnreadMessagesOfSender = (senderName, jsonlFilename) => {
    var path = config.pathToJSONLFiles + "/" + jsonlFilename;
    var array = fs.readFileSync(path).toString().split("\n");
    var jsonArr = [];
    var json = "[";
    if (array.length > 0) {
        var str = array.slice(0, -1).join(','); // +' or '+array.slice(-1);
        json += str;
    }
    else {
        json += "{}";
    }
    json += "]";
    jsonArr = (JSON.parse(json));

    // Filter messages that were send by owner but not read by peers
    var jsonArrFiltered = jsonArr.filter((item) => {
        return item.to.print_name !== senderName;
    });
    // var jsonArrFiltered = jsonArr;

    console.log("helper.getUnreadMessagesOfSender: " + jsonArrFiltered);

    var result = {};
    result = { [senderName]: jsonArrFiltered };

    // concatenate multiple message texts to one
    let senderMsgArr = result[senderName];
    if (senderMsgArr.length > 0) {
        let resultSenderMsgObj = {};
        let counter = 0;
        for (let senderMsgObj of senderMsgArr.reverse()) {
            if (counter === 0) {
                resultSenderMsgObj = senderMsgObj;
            }
            else {
                resultSenderMsgObj.text += ". " + senderMsgObj.text;
            }
            counter++;
        }
        senderMsgArr = [];
        senderMsgArr.push(resultSenderMsgObj);

        result[senderName] = senderMsgArr;
    }

    return (result);
};

/**
 * Turn signal light on (if state is true) or off (if state is false)
 * Calls REST API of myopenhab.org
 */
helper.setSignalLightState = (state) => {

    var data = "";
    if (state == true) {
        data = "144,44,100";
    }
    else {
        data = "0,0,0";
    }

    var options = {
        host: 'myopenhab.org',
        path: '/rest/items/hue_0210_0017881c3123_2_color',
        port: '443',
        method: 'POST',
        headers: {
            "content-type": "text/plain",
            "authorization": "Basic Y2hyaXN0b2Yua29zdEBnbWFpbC5jb206a2luZGVza2luZGJlc2NoZGU=",
            "cache-control": "no-cache"
        }
    };

    var request = https.request(options, function (res) {
        console.log('STATUS: ' + res.statusCode);
        console.log('HEADERS: ' + JSON.stringify(res.headers));
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
            console.log('BODY: ' + chunk);
        });
    });

    request.on('error', function (e) {
        console.log('problem with request: ' + e.message);
    });

    request.write(data);
    request.end();
};

/**
 * Turn off signal light (when message is marked read)
 */
helper.turnOffMsgSignal = () => {
    return new Promise((resolve, reject) => {
        helper.setSignalLightState(false);
        resolve("Signal light: off");
    });
};

module.exports = helper;